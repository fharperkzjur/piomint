// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AILabRunClient is the client API for AILabRun service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AILabRunClient interface {
	CreateTrain(ctx context.Context, in *ReqCreateTrain, opts ...grpc.CallOption) (*ReplyHeader, error)
	CreateTrainEvaluate(ctx context.Context, in *ReqCreateTrainEval, opts ...grpc.CallOption) (*ReplyHeader, error)
	SaveTrain(ctx context.Context, in *ReqSaveTrain, opts ...grpc.CallOption) (*ReplyHeader, error)
	StartTrainVisual(ctx context.Context, in *ReqStartTrainVisual, opts ...grpc.CallOption) (*ReplyHeader, error)
	StopTrainVisual(ctx context.Context, in *ReqStopTrainVisual, opts ...grpc.CallOption) (*ReplyHeader, error)
	ListRuns(ctx context.Context, in *ReqListRuns, opts ...grpc.CallOption) (*AILabRunList, error)
	// pause|resume|kill runs , need run code support !
	CtrlRun(ctx context.Context, in *ReqCtrlRun, opts ...grpc.CallOption) (*ReplyHeader, error)
	QueryRun(ctx context.Context, in *ReqTarget, opts ...grpc.CallOption) (*AILabRunDetail, error)
	StatsRuns(ctx context.Context, in *ReqStatsRuns, opts ...grpc.CallOption) (*AILabRunStats, error)
	DeleteLabRuns(ctx context.Context, in *ReqTarget, opts ...grpc.CallOption) (*ReplyHeader, error)
	// manually cleanup labs & runs
	CleanLabRuns(ctx context.Context, in *ReqTarget, opts ...grpc.CallOption) (*ReplyHeader, error)
	// set auto cleanup strategy
	SetCleanStrategy(ctx context.Context, in *ReqCleanStrategy, opts ...grpc.CallOption) (*ReplyHeader, error)
}

type aILabRunClient struct {
	cc grpc.ClientConnInterface
}

func NewAILabRunClient(cc grpc.ClientConnInterface) AILabRunClient {
	return &aILabRunClient{cc}
}

func (c *aILabRunClient) CreateTrain(ctx context.Context, in *ReqCreateTrain, opts ...grpc.CallOption) (*ReplyHeader, error) {
	out := new(ReplyHeader)
	err := c.cc.Invoke(ctx, "/AILabRun/CreateTrain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabRunClient) CreateTrainEvaluate(ctx context.Context, in *ReqCreateTrainEval, opts ...grpc.CallOption) (*ReplyHeader, error) {
	out := new(ReplyHeader)
	err := c.cc.Invoke(ctx, "/AILabRun/CreateTrainEvaluate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabRunClient) SaveTrain(ctx context.Context, in *ReqSaveTrain, opts ...grpc.CallOption) (*ReplyHeader, error) {
	out := new(ReplyHeader)
	err := c.cc.Invoke(ctx, "/AILabRun/SaveTrain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabRunClient) StartTrainVisual(ctx context.Context, in *ReqStartTrainVisual, opts ...grpc.CallOption) (*ReplyHeader, error) {
	out := new(ReplyHeader)
	err := c.cc.Invoke(ctx, "/AILabRun/StartTrainVisual", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabRunClient) StopTrainVisual(ctx context.Context, in *ReqStopTrainVisual, opts ...grpc.CallOption) (*ReplyHeader, error) {
	out := new(ReplyHeader)
	err := c.cc.Invoke(ctx, "/AILabRun/StopTrainVisual", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabRunClient) ListRuns(ctx context.Context, in *ReqListRuns, opts ...grpc.CallOption) (*AILabRunList, error) {
	out := new(AILabRunList)
	err := c.cc.Invoke(ctx, "/AILabRun/ListRuns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabRunClient) CtrlRun(ctx context.Context, in *ReqCtrlRun, opts ...grpc.CallOption) (*ReplyHeader, error) {
	out := new(ReplyHeader)
	err := c.cc.Invoke(ctx, "/AILabRun/CtrlRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabRunClient) QueryRun(ctx context.Context, in *ReqTarget, opts ...grpc.CallOption) (*AILabRunDetail, error) {
	out := new(AILabRunDetail)
	err := c.cc.Invoke(ctx, "/AILabRun/QueryRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabRunClient) StatsRuns(ctx context.Context, in *ReqStatsRuns, opts ...grpc.CallOption) (*AILabRunStats, error) {
	out := new(AILabRunStats)
	err := c.cc.Invoke(ctx, "/AILabRun/StatsRuns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabRunClient) DeleteLabRuns(ctx context.Context, in *ReqTarget, opts ...grpc.CallOption) (*ReplyHeader, error) {
	out := new(ReplyHeader)
	err := c.cc.Invoke(ctx, "/AILabRun/DeleteLabRuns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabRunClient) CleanLabRuns(ctx context.Context, in *ReqTarget, opts ...grpc.CallOption) (*ReplyHeader, error) {
	out := new(ReplyHeader)
	err := c.cc.Invoke(ctx, "/AILabRun/CleanLabRuns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabRunClient) SetCleanStrategy(ctx context.Context, in *ReqCleanStrategy, opts ...grpc.CallOption) (*ReplyHeader, error) {
	out := new(ReplyHeader)
	err := c.cc.Invoke(ctx, "/AILabRun/SetCleanStrategy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AILabRunServer is the server API for AILabRun service.
// All implementations must embed UnimplementedAILabRunServer
// for forward compatibility
type AILabRunServer interface {
	CreateTrain(context.Context, *ReqCreateTrain) (*ReplyHeader, error)
	CreateTrainEvaluate(context.Context, *ReqCreateTrainEval) (*ReplyHeader, error)
	SaveTrain(context.Context, *ReqSaveTrain) (*ReplyHeader, error)
	StartTrainVisual(context.Context, *ReqStartTrainVisual) (*ReplyHeader, error)
	StopTrainVisual(context.Context, *ReqStopTrainVisual) (*ReplyHeader, error)
	ListRuns(context.Context, *ReqListRuns) (*AILabRunList, error)
	// pause|resume|kill runs , need run code support !
	CtrlRun(context.Context, *ReqCtrlRun) (*ReplyHeader, error)
	QueryRun(context.Context, *ReqTarget) (*AILabRunDetail, error)
	StatsRuns(context.Context, *ReqStatsRuns) (*AILabRunStats, error)
	DeleteLabRuns(context.Context, *ReqTarget) (*ReplyHeader, error)
	// manually cleanup labs & runs
	CleanLabRuns(context.Context, *ReqTarget) (*ReplyHeader, error)
	// set auto cleanup strategy
	SetCleanStrategy(context.Context, *ReqCleanStrategy) (*ReplyHeader, error)
	mustEmbedUnimplementedAILabRunServer()
}

// UnimplementedAILabRunServer must be embedded to have forward compatible implementations.
type UnimplementedAILabRunServer struct {
}

func (UnimplementedAILabRunServer) CreateTrain(context.Context, *ReqCreateTrain) (*ReplyHeader, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTrain not implemented")
}
func (UnimplementedAILabRunServer) CreateTrainEvaluate(context.Context, *ReqCreateTrainEval) (*ReplyHeader, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTrainEvaluate not implemented")
}
func (UnimplementedAILabRunServer) SaveTrain(context.Context, *ReqSaveTrain) (*ReplyHeader, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveTrain not implemented")
}
func (UnimplementedAILabRunServer) StartTrainVisual(context.Context, *ReqStartTrainVisual) (*ReplyHeader, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTrainVisual not implemented")
}
func (UnimplementedAILabRunServer) StopTrainVisual(context.Context, *ReqStopTrainVisual) (*ReplyHeader, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopTrainVisual not implemented")
}
func (UnimplementedAILabRunServer) ListRuns(context.Context, *ReqListRuns) (*AILabRunList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRuns not implemented")
}
func (UnimplementedAILabRunServer) CtrlRun(context.Context, *ReqCtrlRun) (*ReplyHeader, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CtrlRun not implemented")
}
func (UnimplementedAILabRunServer) QueryRun(context.Context, *ReqTarget) (*AILabRunDetail, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRun not implemented")
}
func (UnimplementedAILabRunServer) StatsRuns(context.Context, *ReqStatsRuns) (*AILabRunStats, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatsRuns not implemented")
}
func (UnimplementedAILabRunServer) DeleteLabRuns(context.Context, *ReqTarget) (*ReplyHeader, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLabRuns not implemented")
}
func (UnimplementedAILabRunServer) CleanLabRuns(context.Context, *ReqTarget) (*ReplyHeader, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CleanLabRuns not implemented")
}
func (UnimplementedAILabRunServer) SetCleanStrategy(context.Context, *ReqCleanStrategy) (*ReplyHeader, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCleanStrategy not implemented")
}
func (UnimplementedAILabRunServer) mustEmbedUnimplementedAILabRunServer() {}

// UnsafeAILabRunServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AILabRunServer will
// result in compilation errors.
type UnsafeAILabRunServer interface {
	mustEmbedUnimplementedAILabRunServer()
}

func RegisterAILabRunServer(s grpc.ServiceRegistrar, srv AILabRunServer) {
	s.RegisterService(&AILabRun_ServiceDesc, srv)
}

func _AILabRun_CreateTrain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqCreateTrain)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabRunServer).CreateTrain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AILabRun/CreateTrain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabRunServer).CreateTrain(ctx, req.(*ReqCreateTrain))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILabRun_CreateTrainEvaluate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqCreateTrainEval)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabRunServer).CreateTrainEvaluate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AILabRun/CreateTrainEvaluate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabRunServer).CreateTrainEvaluate(ctx, req.(*ReqCreateTrainEval))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILabRun_SaveTrain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqSaveTrain)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabRunServer).SaveTrain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AILabRun/SaveTrain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabRunServer).SaveTrain(ctx, req.(*ReqSaveTrain))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILabRun_StartTrainVisual_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqStartTrainVisual)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabRunServer).StartTrainVisual(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AILabRun/StartTrainVisual",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabRunServer).StartTrainVisual(ctx, req.(*ReqStartTrainVisual))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILabRun_StopTrainVisual_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqStopTrainVisual)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabRunServer).StopTrainVisual(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AILabRun/StopTrainVisual",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabRunServer).StopTrainVisual(ctx, req.(*ReqStopTrainVisual))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILabRun_ListRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqListRuns)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabRunServer).ListRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AILabRun/ListRuns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabRunServer).ListRuns(ctx, req.(*ReqListRuns))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILabRun_CtrlRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqCtrlRun)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabRunServer).CtrlRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AILabRun/CtrlRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabRunServer).CtrlRun(ctx, req.(*ReqCtrlRun))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILabRun_QueryRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqTarget)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabRunServer).QueryRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AILabRun/QueryRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabRunServer).QueryRun(ctx, req.(*ReqTarget))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILabRun_StatsRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqStatsRuns)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabRunServer).StatsRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AILabRun/StatsRuns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabRunServer).StatsRuns(ctx, req.(*ReqStatsRuns))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILabRun_DeleteLabRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqTarget)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabRunServer).DeleteLabRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AILabRun/DeleteLabRuns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabRunServer).DeleteLabRuns(ctx, req.(*ReqTarget))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILabRun_CleanLabRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqTarget)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabRunServer).CleanLabRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AILabRun/CleanLabRuns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabRunServer).CleanLabRuns(ctx, req.(*ReqTarget))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILabRun_SetCleanStrategy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqCleanStrategy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabRunServer).SetCleanStrategy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AILabRun/SetCleanStrategy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabRunServer).SetCleanStrategy(ctx, req.(*ReqCleanStrategy))
	}
	return interceptor(ctx, in, info, handler)
}

// AILabRun_ServiceDesc is the grpc.ServiceDesc for AILabRun service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AILabRun_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "AILabRun",
	HandlerType: (*AILabRunServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTrain",
			Handler:    _AILabRun_CreateTrain_Handler,
		},
		{
			MethodName: "CreateTrainEvaluate",
			Handler:    _AILabRun_CreateTrainEvaluate_Handler,
		},
		{
			MethodName: "SaveTrain",
			Handler:    _AILabRun_SaveTrain_Handler,
		},
		{
			MethodName: "StartTrainVisual",
			Handler:    _AILabRun_StartTrainVisual_Handler,
		},
		{
			MethodName: "StopTrainVisual",
			Handler:    _AILabRun_StopTrainVisual_Handler,
		},
		{
			MethodName: "ListRuns",
			Handler:    _AILabRun_ListRuns_Handler,
		},
		{
			MethodName: "CtrlRun",
			Handler:    _AILabRun_CtrlRun_Handler,
		},
		{
			MethodName: "QueryRun",
			Handler:    _AILabRun_QueryRun_Handler,
		},
		{
			MethodName: "StatsRuns",
			Handler:    _AILabRun_StatsRuns_Handler,
		},
		{
			MethodName: "DeleteLabRuns",
			Handler:    _AILabRun_DeleteLabRuns_Handler,
		},
		{
			MethodName: "CleanLabRuns",
			Handler:    _AILabRun_CleanLabRuns_Handler,
		},
		{
			MethodName: "SetCleanStrategy",
			Handler:    _AILabRun_SetCleanStrategy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ai_lab_runs.proto",
}
