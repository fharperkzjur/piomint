// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AILabClient is the client API for AILab service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AILabClient interface {
	CreateLab(ctx context.Context, in *ReqCreateLab, opts ...grpc.CallOption) (*ReplyHeader, error)
	ListLabs(ctx context.Context, in *ReqListLabs, opts ...grpc.CallOption) (*ReplyListLabs, error)
	QueryLab(ctx context.Context, in *ReqTarget, opts ...grpc.CallOption) (*AILabDetail, error)
	DeleteLab(ctx context.Context, in *ReqTarget, opts ...grpc.CallOption) (*ReplyHeader, error)
	UpdateLab(ctx context.Context, in *ReqUpdateLab, opts ...grpc.CallOption) (*ReplyHeader, error)
	BatchCreateLab(ctx context.Context, in *ReqBatchCreateLab, opts ...grpc.CallOption) (*ReplyHeader, error)
	BatchDeleteLab(ctx context.Context, in *ReqTarget, opts ...grpc.CallOption) (*ReplyHeader, error)
}

type aILabClient struct {
	cc grpc.ClientConnInterface
}

func NewAILabClient(cc grpc.ClientConnInterface) AILabClient {
	return &aILabClient{cc}
}

func (c *aILabClient) CreateLab(ctx context.Context, in *ReqCreateLab, opts ...grpc.CallOption) (*ReplyHeader, error) {
	out := new(ReplyHeader)
	err := c.cc.Invoke(ctx, "/bmod.ai_lab.AILab/CreateLab", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabClient) ListLabs(ctx context.Context, in *ReqListLabs, opts ...grpc.CallOption) (*ReplyListLabs, error) {
	out := new(ReplyListLabs)
	err := c.cc.Invoke(ctx, "/bmod.ai_lab.AILab/ListLabs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabClient) QueryLab(ctx context.Context, in *ReqTarget, opts ...grpc.CallOption) (*AILabDetail, error) {
	out := new(AILabDetail)
	err := c.cc.Invoke(ctx, "/bmod.ai_lab.AILab/QueryLab", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabClient) DeleteLab(ctx context.Context, in *ReqTarget, opts ...grpc.CallOption) (*ReplyHeader, error) {
	out := new(ReplyHeader)
	err := c.cc.Invoke(ctx, "/bmod.ai_lab.AILab/DeleteLab", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabClient) UpdateLab(ctx context.Context, in *ReqUpdateLab, opts ...grpc.CallOption) (*ReplyHeader, error) {
	out := new(ReplyHeader)
	err := c.cc.Invoke(ctx, "/bmod.ai_lab.AILab/UpdateLab", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabClient) BatchCreateLab(ctx context.Context, in *ReqBatchCreateLab, opts ...grpc.CallOption) (*ReplyHeader, error) {
	out := new(ReplyHeader)
	err := c.cc.Invoke(ctx, "/bmod.ai_lab.AILab/BatchCreateLab", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aILabClient) BatchDeleteLab(ctx context.Context, in *ReqTarget, opts ...grpc.CallOption) (*ReplyHeader, error) {
	out := new(ReplyHeader)
	err := c.cc.Invoke(ctx, "/bmod.ai_lab.AILab/BatchDeleteLab", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AILabServer is the server API for AILab service.
// All implementations must embed UnimplementedAILabServer
// for forward compatibility
type AILabServer interface {
	CreateLab(context.Context, *ReqCreateLab) (*ReplyHeader, error)
	ListLabs(context.Context, *ReqListLabs) (*ReplyListLabs, error)
	QueryLab(context.Context, *ReqTarget) (*AILabDetail, error)
	DeleteLab(context.Context, *ReqTarget) (*ReplyHeader, error)
	UpdateLab(context.Context, *ReqUpdateLab) (*ReplyHeader, error)
	BatchCreateLab(context.Context, *ReqBatchCreateLab) (*ReplyHeader, error)
	BatchDeleteLab(context.Context, *ReqTarget) (*ReplyHeader, error)
	mustEmbedUnimplementedAILabServer()
}

// UnimplementedAILabServer must be embedded to have forward compatible implementations.
type UnimplementedAILabServer struct {
}

func (UnimplementedAILabServer) CreateLab(context.Context, *ReqCreateLab) (*ReplyHeader, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLab not implemented")
}
func (UnimplementedAILabServer) ListLabs(context.Context, *ReqListLabs) (*ReplyListLabs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLabs not implemented")
}
func (UnimplementedAILabServer) QueryLab(context.Context, *ReqTarget) (*AILabDetail, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryLab not implemented")
}
func (UnimplementedAILabServer) DeleteLab(context.Context, *ReqTarget) (*ReplyHeader, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLab not implemented")
}
func (UnimplementedAILabServer) UpdateLab(context.Context, *ReqUpdateLab) (*ReplyHeader, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLab not implemented")
}
func (UnimplementedAILabServer) BatchCreateLab(context.Context, *ReqBatchCreateLab) (*ReplyHeader, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateLab not implemented")
}
func (UnimplementedAILabServer) BatchDeleteLab(context.Context, *ReqTarget) (*ReplyHeader, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchDeleteLab not implemented")
}
func (UnimplementedAILabServer) mustEmbedUnimplementedAILabServer() {}

// UnsafeAILabServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AILabServer will
// result in compilation errors.
type UnsafeAILabServer interface {
	mustEmbedUnimplementedAILabServer()
}

func RegisterAILabServer(s grpc.ServiceRegistrar, srv AILabServer) {
	s.RegisterService(&AILab_ServiceDesc, srv)
}

func _AILab_CreateLab_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqCreateLab)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabServer).CreateLab(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bmod.ai_lab.AILab/CreateLab",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabServer).CreateLab(ctx, req.(*ReqCreateLab))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILab_ListLabs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqListLabs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabServer).ListLabs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bmod.ai_lab.AILab/ListLabs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabServer).ListLabs(ctx, req.(*ReqListLabs))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILab_QueryLab_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqTarget)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabServer).QueryLab(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bmod.ai_lab.AILab/QueryLab",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabServer).QueryLab(ctx, req.(*ReqTarget))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILab_DeleteLab_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqTarget)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabServer).DeleteLab(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bmod.ai_lab.AILab/DeleteLab",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabServer).DeleteLab(ctx, req.(*ReqTarget))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILab_UpdateLab_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqUpdateLab)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabServer).UpdateLab(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bmod.ai_lab.AILab/UpdateLab",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabServer).UpdateLab(ctx, req.(*ReqUpdateLab))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILab_BatchCreateLab_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqBatchCreateLab)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabServer).BatchCreateLab(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bmod.ai_lab.AILab/BatchCreateLab",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabServer).BatchCreateLab(ctx, req.(*ReqBatchCreateLab))
	}
	return interceptor(ctx, in, info, handler)
}

func _AILab_BatchDeleteLab_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqTarget)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AILabServer).BatchDeleteLab(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bmod.ai_lab.AILab/BatchDeleteLab",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AILabServer).BatchDeleteLab(ctx, req.(*ReqTarget))
	}
	return interceptor(ctx, in, info, handler)
}

// AILab_ServiceDesc is the grpc.ServiceDesc for AILab service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AILab_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bmod.ai_lab.AILab",
	HandlerType: (*AILabServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLab",
			Handler:    _AILab_CreateLab_Handler,
		},
		{
			MethodName: "ListLabs",
			Handler:    _AILab_ListLabs_Handler,
		},
		{
			MethodName: "QueryLab",
			Handler:    _AILab_QueryLab_Handler,
		},
		{
			MethodName: "DeleteLab",
			Handler:    _AILab_DeleteLab_Handler,
		},
		{
			MethodName: "UpdateLab",
			Handler:    _AILab_UpdateLab_Handler,
		},
		{
			MethodName: "BatchCreateLab",
			Handler:    _AILab_BatchCreateLab_Handler,
		},
		{
			MethodName: "BatchDeleteLab",
			Handler:    _AILab_BatchDeleteLab_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ai_lab.proto",
}
